import Foundation
import SwiftData

/// Stage 1: Interval Discovery
/// Discovers time intervals that need syncing by querying HealthKit anchors
/// and creating SyncInterval records for unprocessed periods
@MainActor
final class LayeringService {
    private let healthKitManager: HealthKitManager<HealthKitStatisticsQueryProvider>
    private let modelContext: ModelContext

    /// Interval size for chunking data (default: 1 day)
    private let intervalDuration: TimeInterval

    init(
        healthKitManager: HealthKitManager<HealthKitStatisticsQueryProvider>,
        modelContext: ModelContext,
        intervalDuration: TimeInterval = 86400 // 24 hours
    ) {
        self.healthKitManager = healthKitManager
        self.modelContext = modelContext
        self.intervalDuration = intervalDuration
    }

    /// Discovers new intervals that need to be synced
    /// - Returns: Number of new intervals discovered
    func discoverNewIntervals() async throws -> Int {
        // Get the last synced date from SyncInterval records
        let lastSyncedDate = try await getLastSyncedDate()

        // Get available data range from HealthKit
        let availableDataEnd = Date()

        // Generate intervals from last synced date to now
        let intervals = generateIntervals(from: lastSyncedDate, to: availableDataEnd)

        // Create SyncInterval records for each new interval
        var createdCount = 0
        for interval in intervals {
            // Check if interval already exists
            let exists = try await intervalExists(start: interval.start, end: interval.end)
            if !exists {
                let syncInterval = SyncInterval(
                    startDate: interval.start,
                    endDate: interval.end,
                    status: .pending
                )
                modelContext.insert(syncInterval)
                createdCount += 1
            }
        }

        if createdCount > 0 {
            try modelContext.save()
        }

        return createdCount
    }

    /// Gets the last successfully synced date
    private func getLastSyncedDate() async throws -> Date {
        let descriptor = FetchDescriptor<SyncInterval>(
            sortBy: [SortDescriptor(\.endDate, order: .reverse)]
        )

        let intervals = try modelContext.fetch(descriptor)

        // Return the end date of the last completed interval
        // or a default date if no intervals exist
        if let lastInterval = intervals.first(where: { $0.status == .completed }) {
            return lastInterval.endDate
        }

        // Default to 30 days ago if no sync history
        return Calendar.current.date(byAdding: .day, value: -30, to: Date()) ?? Date()
    }

    /// Generates intervals between two dates
    private func generateIntervals(from start: Date, to end: Date) -> [(start: Date, end: Date)] {
        var intervals: [(start: Date, end: Date)] = []
        var currentStart = start

        while currentStart < end {
            let currentEnd = min(currentStart.addingTimeInterval(intervalDuration), end)
            intervals.append((start: currentStart, end: currentEnd))
            currentStart = currentEnd
        }

        return intervals
    }

    /// Checks if an interval already exists in the database
    private func intervalExists(start: Date, end: Date) async throws -> Bool {
        let predicate = #Predicate<SyncInterval> { interval in
            interval.startDate == start && interval.endDate == end
        }

        let descriptor = FetchDescriptor<SyncInterval>(predicate: predicate)
        let intervals = try modelContext.fetch(descriptor)

        return !intervals.isEmpty
    }

    /// Gets all pending intervals ready for fetching
    func getPendingIntervals() async throws -> [SyncInterval] {
        let predicate = #Predicate<SyncInterval> { interval in
            interval.status.rawValue == "pending"
        }

        let descriptor = FetchDescriptor<SyncInterval>(
            predicate: predicate,
            sortBy: [SortDescriptor(\.startDate, order: .forward)]
        )

        return try modelContext.fetch(descriptor)
    }
}
